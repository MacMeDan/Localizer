//
//  ResourceGenerator.swift
//  Localizer
//
//  Created by Dan Leonard on 3/6/18.
//  Copyright Â© 2018 MacMeDan. All rights reserved.
//

import Foundation

/// SET PATHS TO YOUR PROJECT FILES
    //"/Users/YOUR_USER/PATH_TO_YOUR_PROJECT/"
var pathToProject: String = "/Users/macmedan/Swift/Localizer/"

let projectDirectory = URL(fileURLWithPath: pathToProject)

// NOTE: This path is relative to the pathToProject path
///"/PATH_TO_THE_LOCALIZABLE_STRINGS_FILE/"
var sourceFilePath: String = "Localizer/ExampleProducts/Localizable.strings"
var originalLocalizedFilePath: String = "Localizer/ExampleProducts/OriginalLocalizable.strings"

// NOTE: This path is relative to the pathToProject path
///"/Users/YOUR_USER/PATH_TO_RESOURCES_STRINGS_FILE/"
var resourceFilePath: String = "Localizer/ExampleProducts/Resources.swift"

var numberOfUnlocalisedStrings: Int = 0

//These are values that the script checks against. If one of these values is found on a line where a unlocalized string is located then the line is skipped. You can add your own values to the list to fine tune it specific to your projcet.
let ignoreLinesContaining:[String] = [
    "assert",
    "Error",
    "Log",
    "RegularExpression",
    "MutableProperty",
    "log",
    "\\", // escaped \ for skipping wrapped variables "\($0)"
    "///", // for skipping comments
    "//",
    "json",
    "|", // for skipping visualFormat layout code
    ".trim()",
    "Mismatch",
    "webView",
    "tag",
    "ViewControllerFactory",
    "Identifier",
    "Condition"
]

func checkIgnoredValues(value: String) -> Bool {
    var result: Bool = false
    ignoreLinesContaining.forEach {
        if value.contains($0) {
            result = true
        }
    }
    return result
}

func findUnlocalisedStrings(fromFilePath: String) {
    do {
        let data = try String(contentsOf: projectDirectory.appendingPathComponents(fromFilePath.components(separatedBy: "/")), encoding: .utf8)
        let myStrings = data.components(separatedBy: .newlines)
        let converted: [String] = myStrings.map { line in
            if checkIgnoredValues(value: line) {
                return line
            }
            var components = line.components(separatedBy: "\"")
            for item in 0...components.count-1 {
                if item % 2 == 1 {
                    components[item] = convertToResourceRef(components[item])
                }
            }
            return components.joined()
        }
        writeData(converted.joined(separator: "\n"), path: fromFilePath.components(separatedBy: "/")) { _ in
            print("""
                ðŸ¤¯ Converted \(fromFilePath.components(separatedBy: "/").last!)
                total of \(numberOfUnlocalisedStrings) strings converted
                """)
        }
    } catch {
        assertionFailure(error.localizedDescription)
    }
}

func writeData( _ newData: String, path: [String], completion:((String) -> Void)) {
    do {
        try newData.write(to: projectDirectory.appendingPathComponents(path), atomically: true, encoding: .utf8)
        completion("Sucsess Writing to path: \(path)")
    } catch {
        completion(error.localizedDescription)
    }
}

func generateResourceEnum() {
    let newValues = Array(NSDictionary(contentsOf: projectDirectory.appendingPathComponents(sourceFilePath.components(separatedBy: "/"))).flatMap{$0}!).sorted{($0.0 as! String) < ($1.0 as! String)}

    let staticFunctions = newValues.map {
        """

        \t/** \(($1 as! String)) */
        \tstatic var \($0) = {
        \t\tNSLocalizedString("\($0)", comment: "\(($1 as! String).exscapeNewLine)")}()

        """
        }.joined()

    let contents = """
    //
    //  R.swift
    //  InspectionTool
    //
    //  Created by Dan Leonard on 3/1/18.
    //
    //  This file is autogenerated by \((#file as NSString).lastPathComponent)
    //  Check out the project @ https://github.com/MacMeDan/Localizer
    //
    // `R` represents Resource a common practace used in other development enviroments.
    //

    import Foundation

    enum R {
    \(staticFunctions)
    }

    """

    writeData(contents, path: resourceFilePath.components(separatedBy: "/")) { _ in
        numberOfUnlocalisedStrings += 1
    }
}

func addEntry(key: String? = nil, value rawValue: String) -> (key: Any, value: Any) {
    if let key = key {
        return (key: key, value: rawValue.exscapeNewLine)
    } else {
        return (key: rawValue.camelCased, value: rawValue.exscapeNewLine)
    }
}

func entryAsString(key: String? = nil, value rawValue: String) -> String? {
    if let key = key {
        return "\n/** \(rawValue.camelCased) **/\n\"\(key)\" = \"\(rawValue.exscapeNewLine)\";\n"
    } else {
        return "\n/** \(rawValue.exscapeNewLine) **/\n\"\(rawValue.camelCased)\" = \"\(rawValue.exscapeNewLine)\";\n"
    }
}

func convertToResourceRef(_ input: String) -> String {
    // This handles the case where there is a empty string on a line often used as a default value for an optional ie ` $0 ?? "" `
    if input.camelCased == "" {
        return "\"\""
    } else {
        locolizeNewString(input)
        return "R.\(input.camelCased)"
    }
}

func locolizeNewString( _ newString: String, newKey: String? = nil) {

    let componets = sourceFilePath.components(separatedBy: "/")
    var allValues = Array(NSDictionary(contentsOf: projectDirectory
        .appendingPathComponents(componets))
        .flatMap{$0}!)

    allValues.append(addEntry( key: newKey, value: newString))

    let newData = allValues.sorted{($0.1 as! String) < ($1.1 as! String)}.flatMap{
        entryAsString(key: $0.0 as? String, value: $0.1 as! String)
        }.joined()

    writeData(newData, path: sourceFilePath.components(separatedBy: "/")) { _ in
        generateResourceEnum()
    }
}

func generateNewStringsFile() {
    var newData: String
    let componets = sourceFilePath.components(separatedBy: "/")
    let allValues = Array(Set(NSDictionary(contentsOf: projectDirectory.appendingPathComponents(componets))!.allValues as! [String]))
    newData = allValues.flatMap{ entryAsString(value: $0) }.joined()

    writeData(newData, path: sourceFilePath.components(separatedBy: "/")) { _ in
        generateResourceEnum()
    }
}

func generateNewStringsSortedByKey() {
    var newData: String
    let allValues = Array(NSDictionary(contentsOf: projectDirectory.appendingPathComponents(sourceFilePath.components(separatedBy: "/"))).flatMap{$0}!).sorted{($0.1 as! String) < ($1.1 as! String)}
    newData = allValues.flatMap{ entryAsString(key: $0.0 as! String, value: $0.1 as! String) }.joined()

    writeData(newData, path: sourceFilePath.components(separatedBy: "/")) { _ in
        generateResourceEnum()
    }
}

