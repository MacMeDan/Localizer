//
//  FileLocalizer.swift
//  Localizer
//
//  Created by Dan Leonard on 3/15/18.
//  Copyright Â© 2018 MacMeDan. All rights reserved.
//
//
///  Purpose:
///     find raw strings in provided file replace them wiht reference to Resource enum
///     and add new localized entry to the Localizeable.strings file
///  Output:
///      The input file with strings replaced with R.camelCased where strings were
///      Autogenerated case in Resources.swift
///      Autogenerated entry in Loalisable.strings
///

import Foundation


/// Searches all files within a specified directroy and pulls out any unlocalised strings
class FileLocalizer {

    /**
     These are values that the script checks against so that it does not locolize things you do not want locolized.
     If one of these values is found on a line where a unlocalized string is located then the line is skipped.
     You can add your own values to the list to fine tune it specific to your projcet.
     **/
    let ignoreLinesContaining: [String] = [
        "assert",
        "Error",
        "Log",
        "RegularExpression",
        "MutableProperty",
        "log",              //Skip log messages
        "\\",               // escaped \ for skipping wrapped variables "\($0)"
        "///",              // Don't want to localise comments
        "//",
        "json",
        "|",                // skip visualFormat layout code
        ".trim()",
        "Mismatch",
        "webView",
        "tag",
        "ViewControllerFactory",
        "Identifier",
        "Condition",
        "case",
        "resourceName"
    ]


    /// Checks to see if a line should be skipped
    ///
    /// - Parameter value: A single line of a file
    /// - Returns: True if it should be skiped
    func checkIgnoredValues(line: String) -> Bool {
        var result: Bool = false
        ignoreLinesContaining.forEach {
            if line.contains($0) {
                result = true
            }
        }
        return result
    }
    
    func findUnlocalisedStringsIn(file filePath: String) {
        let fileURL = baseFolderURL
            .appendingPathComponents(filePath.components(separatedBy: "/"))
        do {

            let fileData = try String(
                contentsOf: baseFolderURL
                    .appendingPathComponents(
                        filePath.components(separatedBy: "/")
            ),
                encoding: .utf8
            )

            let lines = fileData.components(separatedBy: .newlines)

            let converted: [String] = lines.map { line in

                if checkIgnoredValues(line: line) { return line }
                var components = line.components(separatedBy: "\"")
                for item in 0...components.count-1 {
                    if item % 2 == 1 {
                        components[item] = convertToResourceRef(components[item])
                    }
                }
                return components.joined()
            }

            writeData(converted.joined(separator: "\n"), path: fileURL) { _ in
                print("ðŸ¤¯ Converted \(numberOfUnlocalisedStrings) \(fileURL.lastPathComponent)")
            }

        } catch {
            assertionFailure(error.localizedDescription)
        }
    }

    /// Converts a string to the entry in the Resource enum.
    ///
    /// - Parameter input: a raw String
    /// - Returns: reference to Resource Enum

    private func convertToResourceRef(_ input: String) -> String {

        /// Edge case where an empty string is used as a default value for an optional IE ` $0 ?? "" `

        if input.camelCased == "" { return "\"\"" }

        localize(newString: input)

        return "R.\(input.camelCased)"

    }

    /// Generates all neccecery components to add a new localised string to project
    ///
    /// - Parameters:
    ///   - newString: any raw String
    ///   - newKey: optional Key defaults to cammelCased representation of `newString`
    func localize(newString: String, newKey: String? = nil) {

        let bundle = Bundle(for: type(of: self))
        guard let urlToLocalizable = bundle.url(forResource: "Localisable", withExtension: "strings") else {
            assertionFailure("Could not find localisable.strings file")
            return
        }
        
        var allValues = Array(
            NSDictionary( contentsOf: urlToLocalizable)
                .flatMap{$0}!
        )

        let newEntry = addEntry(key: newKey, value: newString)
        allValues.append(newEntry)

        let newData = allValues
            .sorted{($0.1 as! String) < ($1.1 as! String)}
            .flatMap{ LocalisableGenerator().getCommentAndEntry(key: $0.0 as? String, value: $0.1 as! String) }
            .joined()

        writeData(newData, path: urlToLocalizable) { _ in
            ResourceGenerator().generate()
        }
    }

    /// Adds a new localisation entry to the localisable.strings file
    ///
    /// - Parameters:
    ///   - key: Optional Key can be specified defaults to camelCased interpritation of required rawValue
    ///   - rawValue: any String
    /// - Returns: a Tuple (key, value)
    private func addEntry(key: String? = nil, value rawValue: String) -> (key: Any, value: Any) {
        return (key: key ?? rawValue.camelCased, value: rawValue.exscapeNewLine)
    }

}



